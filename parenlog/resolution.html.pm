#lang pollen
◊h2{Resolution}
◊h3{A mechanism for automated reasoning}
◊todo{Maybe write this up with less hand-waving in the mechanisms section and jump directly to the procedural explanation...}
The idea behind resolution is very simple. Let's say you have two disjunctions in propositional logic --- just think two ◊code{or}-expressions without any unbound variables, nested inside an ◊code{and}-expression. If one disjunction contains a boolean expression ◊math{A} and the other contains the opposite expression, ◊math{¬A}, we can drop both ◊math{A} and ◊math{¬A}.

Consider the following expression in Racket syntax: ◊code{(and (or a? b? c?) (or d? (not b?) e?))}. Suppose ◊code{b?} is ◊code{#t}. Then, ◊code{(not b?)} is ◊code{#f}, so we just need ◊code{d?} or ◊code{e?} to be true for the entire ◊code{and}-expression to be true. And if ◊code{b?} is ◊code{#f}, we just need ◊code{a?} or ◊code{c?}. So the whole thing can be expressed as ◊code{(or a? c? d? e?)}. Seems almost trivial, but with a straightforward extension to predicate logic --- logic with variables --- we get a system for automated reasoning.

We'll use the running example:
◊includecode["code/theory.pl" #:lang "prolog"]

Let's say you have two disjunctions again, but this time there are logic variables involved. I'll write them in a syntax closer to that typically used in logic: ◊code{¬likes(X,Y) ∨ ¬part(Y,Z) ∨ likes(X,Z)} and ◊code{¬likes(athena,math)}. The way to read this is with implicit universal quantification at the start, so "for all unknowns ◊math{X}, ◊math{Y} and ◊math{Z}, at least one of the following holds: ◊math{X} does not like ◊math{Y} ◊em{or} ◊math{Y} is not a part of ◊math{Z} ◊em{or} ◊math{X} likes ◊math{Z}. This sounds complicated, but it's ◊a[#:href "https://en.wikipedia.org/wiki/Material_conditional"]{equivalent} with our rule ◊code{likes(X,Y) :- part(Z,Y), likes(X,Z)}. The negation of ◊code{¬likes(athena,math)} does not occur in the actual disjunction. But a negated ◊code{¬likes} predicate does occur. And if we replace ◊code{X} with ◊code{athena} and ◊code{Z} with ◊code{math}, we get ◊code{¬likes(athena,Y) ∨ ¬part(Y,math) ∨ likes(athena,math)}. That's just like ◊code{(and (or a b c) (not a))}, so we can also write ◊code{¬likes(athena,Y) ∨ ¬part(Y,math)}. This resulting disjunction means "any unknown ◊math{Y} is not liked by Athena or is not a part of math." Turns out, that's not true. Athena does not like primes or triangles, but they are a part of math. So the statement we derived was false, even though the rules we applied made sense. Therefore, our initial assumption, formulated as ◊code{¬likes(athena,math)}, was incorrect and ◊code{likes(athena,math)} must hold. Lo and behold, we have actually proven ◊code{likes(athena,math)}!

More generally, we can apply the same idea for resolution as in propositional logic after we unify some element of disjunction number one with some element of disjunction number two to derive implied information. And if that implied information is contradictory, the original disjunctions must be contradictory, as well.

That's the idea behind resolution. But we don't have to bother with inverting truth values for an implementation. If we want to prove that ◊math{X} likes ◊math{Y}, where ◊math{X} stands for Athena and ◊math{Y} stands for math, the rule we worked with earlier means that it suffices to find some ◊math{Z} which is a part of mathematics and which is liked by Athena. So, to prove ◊math{A}, we just need to prove something which implies ◊math{A}.